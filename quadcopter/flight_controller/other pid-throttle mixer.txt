extends Node3D

@export var quadcopter: Quadcopter

@export var motor1: Motor
@export var motor2: Motor
@export var motor3: Motor
@export var motor4: Motor

@onready var motors = [motor1, motor2, motor3, motor4]

#motor idle pwm
var motor_idle := 0.1
var PID_mixer_scaling := 1.0

#rates

#PID controllers

#motor config:

#-> <-
#4   2
# \ /
#  ÃŽ
# / \
#3   1
#-> <-

var armed = true

@onready var PID_pitch = $PID_pitch
@onready var PID_roll =$PID_roll
@onready var PID_yaw = $PID_yaw

var highest_pitch_speed = 0

func _physics_process(delta):
	if armed:
		#get input and (rates are already applied)
		var input_throttle = gb.get_throttle_input()
		var input_pitch = -gb.get_pitch_input()
		var input_roll = -gb.get_roll_input()
		var input_yaw = -gb.get_yaw_input()
		
		#make the PIDs figure out the new speeds for pitch, roll and yaw
		var pitch_speed = PID_pitch.compute(delta, input_pitch, quadcopter.imu_pitch_speed) / PID_mixer_scaling
		var roll_speed = PID_roll.compute(delta, input_roll, quadcopter.imu_roll_speed) / PID_mixer_scaling
		var yaw_speed = PID_yaw.compute(delta, input_yaw, quadcopter.imu_yaw_speed) / PID_mixer_scaling
		
		input_throttle = clamp(input_throttle-max(pitch_speed, roll_speed, yaw_speed), 0.0, 1.0)
		

		#mix the pitch, roll and yaw speeds to the velocities of the motors
		var motor_mix = [
			input_throttle - pitch_speed + roll_speed + yaw_speed,
			input_throttle + pitch_speed + roll_speed - yaw_speed,
			input_throttle - pitch_speed - roll_speed - yaw_speed,
			input_throttle + pitch_speed - roll_speed + yaw_speed
			]
		
		# Find range of PID authority
		var mix_min = motor_mix.min()
		var mix_max = motor_mix.min()
		var mix_range = mix_max - mix_min
				
		# Step 5: Normalize & constrain like Betaflight
		if mix_range > 1.0:
			for i in range(4):
				motor_mix[i] /= mix_range

		# Keep throttle inside safe range
		for i in range(4):
			motor_mix[i] = clamp(motor_mix[i], 0.0, 1.0)

		# Step 6: Add motor idle
		for i in range(4):
			motor_mix[i] = max(motor_idle, motor_mix[i])
			
				
		motor1.pwm = motor_mix[0]
		motor2.pwm = motor_mix[1]
		motor3.pwm = motor_mix[2]
		motor4.pwm = motor_mix[3]
		
		$Graphs/GraphA.data.append(input_pitch)
		$Graphs/GraphB.data.append(quadcopter.imu_pitch_speed)
		

func _process(delta: float) -> void:
	if Input.is_action_just_pressed("self_right"):
		quadcopter.global_rotation.z = 0
		quadcopter.global_rotation.x = 0
		reset()
		
	


	

func reset():
	PID_pitch.reset()
	PID_roll.reset()
	PID_yaw.reset()
